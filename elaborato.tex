\documentclass[italian,A4,12pt]{article}
\usepackage[T1]{fontenc}
%\usepackage[uft8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{authblk}
\usepackage{csquotes}
\usepackage{ulem}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{siunitx}

\title{Crittografia classica e quantistica}
\author{Alessandro Minisini}
\affil{Liceo Scientifico Niccolò Copernico}
\date{}
\newtheorem*{defn}{Definizione}

\begin{document}
  \maketitle
  \newpage
  \tableofcontents
  \newpage
  \section{Introduzione}
  La crittografia è l'arte di creare "scritture nascoste", ovvero trovare dei metodi per mascherare dei messaggi in modo che non possano essere compresi da persone non autorizzate a leggerlo. La crittografia è da sempre usata in ambito militare, diplomatico bancario e commerciale per garantire la giusta riservatezza alle comunicazioni tra le varie parti. I primi sistemi di crittografia li possiamo ritrovare nell'antica Grecia: venivano utilizzate delle aste di legno per codificare messaggi su cinture di cuoio, oppure si tendeva a nasconedere il messaggio sotto ai capelli di chi faceva da corriere.
  Col tempo le varie tecniche si sono evolute: vengono creati dei cifrari a \textit{chiave privata}(la chiave per la cifratura permette di deifrare il messaggio), come il cifrario di Cesare descritto in questo elaborato.
  Il grosso problema di questi sistemi è la distribuzione della chiave, che necessita un canale sicuro tra i due interlocutori, non sempre realizzabile.
  Per ovviare al problema, sono stati inventati dei metodi a \textit{chiave pubblica}(la conoscenza della chiave di cifratura non permette la decifrazione) che fanno leva sulle nostre limitate capacità computazionali: uno di questi è l'algoritmo RSA, inventato da Whitfield Diffie e Martin Hellman nel 1976.
  Con la teorizzazione e la creazione dei primi computer quantistici, è sorta la necessità di trovare nuovi sistemi che non possano essere aggirati: nasce quindi negli anni ottanta la \textit{crittografia quantistica}.

    \section{Crittografia a chiave privata: Cifrario di Cesare}
    Il \textit{Cifrario di Cesare} è uno dei più antichi cifrari di cui si abbia traccia storica: veniva utilizzato dal generale romano in ambito militare (per comunicare con i generali sparsi per l'impero) e in ambito domestico per discutere di questioni che dovevano rimanere private.
    Inizialmente Cesare, come scrive lui stesso nel "De bello gallico", cifrava i messaggi scambiando le lettere dell'alfabeto latino con quelle greche:
    \begin{displayquote}[De Bello Gallico V, 48.2-4]
      \textit{ibi ex captivis cognoscit, quae apud Ciceronem gerantur quantoque in periculo res sit.
      Tum cuidam ex equitibus Gallis magnis preamiis persuadet, uti Ciceronem epistulam deferat.
      Hanc Graecis conscriptam litteris mittit, ne intecepta epistula nostra ab hostibus consilia cognoscantur.}
    \end{displayquote}
    Ai tempi di Cesare, questo sistema poteva essere considerato sicuro, poiché lo studio del greco era riservato solo alla classe dirigente romana che poteva permettersi un precettore privato e viaggi di studio in Grecia.\\
    Questo non è l’unico caso accertato di uso di cifrari a trsposizione da parte di Cesare; si sa, infatti, che Cesare ricorreva spessissimo a cifrari per trasposizione, anche per comunicare coi parenti. Sappiamo, in proposito che la cifratura era talmente tanto spesso utilizzata da Cesare, che Valerio Probo dedicò ai suoi cifrari un intero trattato, che purtroppo è andato perduto. Ma ci sono altre testimonianze, come quelle di Svetonio. Si legge infatti nelle “Vite dei Cesari“:
    \begin{displayquote}[Vita di Cesare, 56]
      \textit{Extant et ad Ciceronem, item ad familiares domesticis de rebus, in quibus, si qua occultius perferenda erant, per notas scripsit, id est sic structo litterarum ordine, ut nullum verbum effici posset: quae si qui investigare et persequi velit, quartam elementorum litteram, id est D pro A et perinde reliquas commutet.\\}
    \end{displayquote}
    Come ci dice Svetonio, il cifrario di Cesare era molto semplice da utilizzare: ogni lettera del testo in chiaro viene sostituita con una lettera che si trova ad un numero fissato di posizioni successive. Questi tipi di cifrario si dicono cifrari a sostituzione o scorrimento.\\
    Il funzionamento di questo cifrario può essere descritto tramite l'aritmetica modulare: la funzione che descrive lo scambio della lettera in posizione $x$ è la seguente
    $$f(x)\equiv x+y \mod{m}$$
    dove $m$ è il numero di lettere dell'alfabeto.\\
    Da questa si può ricavare facilmente la funzione inversa, che garantisce la validità della cifratura:
    \begin{align*}
      f(x) & \equiv x+y \mod{m}\\
      f(x)-x & \equiv y \mod{m}\\
      x & \equiv f(x)-y \mod{m}\\
    \end{align*}
    Dunque
    $$f^{-1}(x)\equiv x-y \mod{m}$$
    Questi tipi di cifratura sono ormai considerati obsoleti, pocihé la potenza di calcolo di un computer permette di provare ogni singola combinazione di lettere in un tempo irrisorio.\\
    In realtà, questo tipo di cifratura è stato superato già nel Medioevo. \\ Un matematico arabo chiamato al-Kindi (IX secolo d.C.) elaborò un metodo di decrittazione basato sull'analisi delle frequenze: le lettere più frequenti nel messaggio devono corrispondere con le lettere più usate dalla lingua del messaggio originale. Questo fatto permette di ridurre drasticamente il numero di tentativi necessari, permettendo di decrittare il messaggio anche a mano.\\\\
    Il cifrario di Cesare però costituisce la base di molti altri cifrari conosciuti, come il cifrario di Vigenère, sviluppato nel 1586 dall'omonimo diplomatico francese.
    Questo cifrario introdusse per la prima volta il concetto di \textit{chiave di criptazione}: per poter criptare e decriptare un messagio infatti era necessario essere a conoscienza di una sequenza di caratteri chiamata verme.\\\\
    L'evoluzione di questi sistemi ha portato alla nascita dell'unico sistema crittografico \textit{perfetto}, poiché la sua inviolabilità è stata comprovata da una dimostrazione matematica.\\
    Questo cifrario è noto col nome \textit{One Time Pad}, ed il suo funzionamento è molto semplice.\\
    Per prima cosa ci serve il messaggio $M$,  trasformato in forma numerica, e una chiave $K$ tale che il numero di cifre di $M$ sia minore uguale al numero di cifre di $K$.\\
    Per ottenere il messaggio cifrato $C$ è sufficiente sommare $M$ e $K$ senza tenere conto degli eventuali riporti intermedi.\\
    Per decrittare il messaggio sarà sufficiente sottrarre cifra per cifra $C$ e $K$, sommando dieci agli eventuali risultati negativi.\\
    In seguito è stato riportato un esempio di criptazione e di decriptazione utilizzando questo cifrario:
    \begin{center}
      \begin{tabular}{c c c c c c}
        \multicolumn{6}{c}{\textit{Criptazione}}\\
        Messaggio $M$:&4&5&3&0&0\\
        Chiave casuale $K$:&7&7&7&4&6\\
        \hline
        Risultato $C$: & 1&2&0&4&6\\
      \end{tabular}
    \end{center}
    \begin{center}
      \begin{tabular}{c c c c c c}
        \multicolumn{6}{c}{\textit{Decriptazione}}\\
        Messaggio $C$:&1&2&0&4&6\\
        Chiave casuale $K$:&7&7&7&4&6\\
        Primo risultato dopo la sottrazione:&-6&-5&-7&0&0\\
        Eventuale somma 10:&+10&+10&+10\\
        \hline
        Risultato $M$: & 4&5&3&0&0\\
      \end{tabular}
    \end{center}
    E' importante citare questo cifrario perché verrà poi utilizzato in combinazione con la distribuzione della chiave quantistica.\\
    \newpage
  \section{Crittografia a chiave pubblica}
    I sistemi dicrittografia odierni sono detti a chiave pubblica: ogni persona che vuole parlare in mdoo cirfrato possiede due chiavi, una pubblica e una privata.\\
    Definiamo $E$ l'algoritmo di criptazione, $D$ l'algoritmo di decriptazione e $M$ il messaggio in chiaro da trasmettere. Ci sono quattro algoritmi essenziali per un sistema a chiave pubblica:
    \begin{enumerate}[label=(\alph*)]
      \item Decifrare un messaggio cifrato ritorna il messaggio originale $$D(E(M))=M$$
      \item Anche il procedimento opposto deve ritornare il messaggio $M$ $$E(D(M))=M$$
      \item Sia E che D devono essere sufficientemente facili da calcolare
      \item La chiave pubblica non deve compromettere la segretezza della chiave privata
    \end{enumerate}
    \subsection{Algoritmo RSA}
      In questo specifico sistema utilizza degli algoritmi $E$ e $D$ che si basano sull'aritmetica modulare. Per poterlo utilizzare dobbiamo rappresentare dobbiamo trasformare il messaggio $M$ in forma numerica (ad esempio convertendo le lettere tramite tabella UNICODE). Supponiamo che $M$ sia un numero intero tra $0$ e $n-1$. Se il messaggio è troppo lungo possiamo dividerlo in più parti e criptarle separatamente. Siano $e,d,n$ degli interi positivi e definiamo la coppia $(e,n)$ come chiave pubblica e $(d,n)$ la chiave privata.
      Ora per criptare il messaggio sarà sufficiente elevare $M$ alla $e$ modulo $n$, ottenendo il messaggio cifrato $C$. Per decritpare il messaggio bata elevare $C$ alla $d$ modulo $n$, ottenendo di nuovo $M$.Formalmente, otteniamo le seguenti definizione per $E$ e $D$:
      \begin{equation}
        C\equiv E(M) \equiv M^e \mod{n}
     \end{equation}
      $$M \equiv D(C) \equiv C^d \mod{n}$$
      Ora ci concentriamo sul meodo da seguire per creare le due chiavi (privata e pubblica). Prima di tutto scegliamo due numeri primi $p$, $q$ sufficientemente grandi e li moltiplichiamo per ottenere $n=pq$. Anche se $n$ fa parte della chiave pubblica, la segretezza di $p$ e $q$ è garantita dal fatto che ricavarli da $n$ è un'operazione computazionalmente complessa, impraticabile con i metodi odierni.\\
      Ora rimangono da generare $e$ è $d$. Scegliamo un $d$ sufficientemente grande in modo che sia coprimo con $\varphi(n)$.
      \begin{defn}[Funzione $\varphi$ di Eulero]
        La funzione $\varphi$ di Eulero, detta anche toziente, è una funzione definita, per ogni intero $n$, come il numero di interi compresi tra $1$ ed $n$ che sono coprimi con $n$.\\ Una delle proprietà fondamentali della funzione è la seguente:
        \begin{equation}
          \varphi(ab)=\varphi(a)\cdot \varphi(b) \label{phii}
        \end{equation}
        Notare inoltre che per ogni primo $p$, $\varphi(p)=p-1$.
      \end{defn}
      Per concludere, troviamo $e$ utilizzando i valori $d$, $p$ e $q$, in modo che $e$ sia l'inverso moltiplicativo di $d$ modulo $\varphi(n)$. Ciò significa soddisfare la seguente congruenza
      $$e\cdot d \equiv 1 \mod{\varphi(n)}$$
      ovvero
      $$e\cdot d = k\cdot \varphi(n) +1$$
      per un $k\in\mathbb{Z}$.
      Dalla \eqref{phii}, otteniamo facilmente $\varphi(n)$
      \begin{align*}
        \varphi(n) &= \varphi(p)\cdot\varphi(q)\\
        &= (p-1)(q-1)\\
        &= n-(p+q)+1\\
      \end{align*}
      Per l'aritmetica modulare, l'inverso moltiplicativo di $a$ modulo $m$ esiste se e solo se $a$ ed $m$ sono coprimi. Siccome $d$ e $\varphi(n)$ sono coprimi per ipotesi, allora esiste sicuramente un $e$ tale che sia l'inverso moltiplicaitivo di $d$ e che $1\leq e \leq \varphi(n)$.\\
      A questo punto, dobbiamo verificare che l'algoritmo descritto con le chiavi appena generate soddisfi le condizioni imposte inzialmente.\\
      Innanzitutto notiamo che le condizioni (a) e (b) implicano la stessa condizione, infatti:
      \begin{equation}
        D(E(M))\equiv (E(M))^d\equiv (M^e)^d \mod{n}=M^{e\cdot d} \mod{n} \label{finale}
      \end{equation}
      $$E(D(M))\equiv (D(M))^e\equiv (M^d)^e \mod{n}=M^{e\cdot d} \mod{n}$$

      Siccome $e\cdot d=k\cdot \varphi(n)+1$, possiamo sostituire l'espressione nelle equazioni precedenti, ottenendo:
      $$M^{e\cdot d}\equiv M^{k\cdot \varphi(n)+1} \mod{n}$$.
      Affinché l'algoritmo funzioni, vogliamo che questa espressione valga esattamente $M$. Per provarlo, ricordiamo un'altra propietà della funzione di Eulero: per ogni intero $M$ coprimo con $n$, vale che
      $$M^{\varphi(n)}\equiv 1 \mod{n}$$
      Siccome abbiamo definito $0\leq M \leq n$, sappiamo che $M$ \textit{non} è coprimo con $n$ se e solo se $p\mid M$ o $q\mid M$. Di questi due casi ce ne occupiamo in seguito.
      Per tutti gli altri casi possibili, vale che:
      $$M^{e\cdot d}\equiv M^{k\cdot \varphi(n)+1}\equiv \left(M^{\varphi(n)}\right)^k\cdot M \equiv 1^k\cdot M \mod{n}=M$$
      Come volevasi dimostrare.\\
      Ora analizziamo il caso particolare in cui $p\mid M$ o $q\mid M$. Siccome $M<n$, le due espressioni non possono essere contemporaneamente vere. Senza perdita di generalità, supponiamo che valga $p\mid M$.
      Questa assunzione ci permette di dire che
      $$MCD(M,p)=p$$
      ovvero
      $$M=pt\text{ con }t\in\mathbb{Z}$$
      e che
      $$MCD(M,q)=1$$
      poiché $q$ è primo.
      Per il piccolo teorema di Fermat, sappiamo che:
      \begin{equation}
        M^{q-1}\equiv 1 \mod{q} \label{fermat}
      \end{equation}
      Ora, eleviamo i due membri della \eqref{fermat} alla $k(p-1)$, ottenendo la seguente congruenza (equivalente alla prima):
      $$M^{k(q-1)(p-1)}\equiv 1 \mod{q}$$
      \begin{equation}
          M^{k(q-1)(p-1)}=1+hq \label{fermat1}
      \end{equation}
      per $h\in\mathbb{Z}$.\\
      Ora moltpilichiamo i due membri della \eqref{fermat1} per $M$, ottenendo:
      $$M^{1+k(q-1)(p-1)}=M+Mqh$$
      Ora sostituiamo alcune parti dell'equazione con alcuni risultati ottenuti sopra, nello specifico sappiamo che $(q-1)(p-1)=\varphi(n)$ e che $M=pt$. Otteniamo che:
      \begin{align*}
        M^{1+k\cdot \varphi(n)}&=M+\overbrace{pq}^{n}th\\
        M^{1+k\cdot \varphi(n)}&=M+nth\\
        M^{1+k\cdot \varphi(n)}&\equiv M \mod{n}\\
      \end{align*}
      Sotituiamo $e\cdot d=1+k\cdot \varphi(n)$:
      $$M^{e\cdot d}\equiv M \mod{n}$$
      Che è proprio ciò che volevamo verificare.\\
      La dimostrazone quindi garantisce la validità del sistema di criptazione RSA per ogni $M$.

      \subsection{Sicurezza del sistema RSA}
      La sicurezza dell'algoritmo RSA si basa sul fatto che per calcolare $\varphi(n)$ è necessario fattorizzare $n$, siccome $p$ e $q$ non sono noti.
      Tuttavia, la scomposizione di un numero in fattori primi è un'operazione che richiede molto tempo: tra gli algoritmi più efficienti, qello di Richard Schroeppel fattorizza $n$ in circa $$e^{\sqrt{\ln{n}\cdot\ln{\ln{n}}}}$$
      operazioni. La seguente tabella, stilata dai creatori dell'RSA nel 1978, rappresenta i tempi di calcolo al variare delle cifre di $n$ (assumendo che un'operazione impieghi in media un microsecondo per essere eseguita):
      ~\\
      \begin{center}
        \begin{tabular}{c c c}
          \textbf{Cifre}&\textbf{Numero di operazioni}&\textbf{Tempo impiegato}\\
          50&$1.4\times 10^{10}$&3.9 ore\\
          75&$9.0\times 10^{12}$&104 giorni\\
          100&$2.3\times 10^{15}$&74 anni\\
          200&$1.2\times 10^{23}$&$3.8\times 10^9$ anni\\
          300&$1.5\times 10^{29}$&$4.9\times 10^{15}$ anni\\
          500&$1.3\times 10^{39}$&$4,2\times 10^{25}$ anni\\

        \end{tabular}
      \end{center}
      Nell'algoritmo vengono solitamente usati $n$ con circa 200 cifre: questo ci garantisce che una fattorizzazione del numero non sia praticabile neanche ai giorni nostri, sebbene i computer siano notevolmente migliorati dal punto di vista computazionale.

      \newpage
  \section{La crittografia quantistica}
    Abbiamo acpito che un computer tradizionale non è in grado di scomporre numeri grandi, come quelli utilizzati nell'algotimo presentato, in un tempo ragionevole. Questa incapacità viene sfruttata da moltissimi algoritmi di criptazione e questi vengono utilizzati per proteggere i nostri dati più sensibili, come le credenziali bancarie.
    Nel 1980 il fisico Paul Benioff propone il primo modello di comuter quantistico, basato su dei bit che non sono rappresentati da stati binari (0 e 1), ma da delle particelle subatomiche.
    Queste particelle, a differenza dei bit classici, possono essere forzate in uno stato particolare chiamato \textit{Sovrapposizione Quantistica}, che è in grado di contenere un quantitativo di informazioni enorme.
    Queste informazioni, grazie alle leggi della meccanica quantistica, possono essere processate in un tempo considerevolmente inferiore rispetto ai computer classici.
    Al giorno d'oggi la realizzazione di un computer quantistica è molto complessa (sono necessarie temperature estremamente basse, vicine allo zero assoluto), ma non impossibile: la IBM, la Google e altri centri di ricerca hanno già sviluppato dei computer quantistici che contengono circa 50 qbits (bits quantistici).
    Per quanto riguarda l'algoritmo di fatttorizzazione, nel 1994 l'informatico Peter Shor ha scritto una procedura che riesce a compiere il calcolo il un tempo irrisorio (nello specifico, il numero di operazioni è dell'ordine di $\log^2{N}\cdot\log{\log{N}}\cdot\log{\log{\log{N}}}$); l'unico problema prettamente pratico di questo algoritmo è che necessita all'incirca un milione di qbits per funzionare.
    Con le tecnologie attuali, è impossibile realizzare un computer quantistico così potente, garantendo la validità degli algoritmi classici ancora per molti anni. Tuttavia, un calcolatore del genere potrebbe venir costruito in futuro, quindi c'è comunque la necessità di creare dei sistemi crittografici che siano in grado di resistere ai tentativi di attaco da parte di questi computer.
    Questa nuova branca della crittografia è chiamata \textit{Crittografia Quantistica} e si concentra sul trovare un modo per trasmettere una chiave in modo sicuro sfruttando le leggi della meccanica quantistica.
    I principali algoritmi quantistici sono il BB84, descritto in seguito, che si basa sulla polarizzazione dei fotoni, e l'ERBE, che sfrutta alune proprietà che delle particelle quantistiche "gemelle" possiedono.
    \subsection{Protocollo BB84}
    Il protocollo BB84 è stato sviluppato da Charles H. Bennet e Gilles Brassard nel 1984.
    È stato il primo metodo di crittografia quantistica mai inventato ed è utilizzabile come metodo per comunicare in modo privato una chiave segreta tra due utenti per poi utilizzare un protocollo del tipo OTP, descritto in precedenza.\\
    \subsection{Principi fisici che garantiscono il funzionamento del BB84}
    Per sfruttare questo sistema si utilizza la luce. Per la meccanica quantistica la luce è composta da quantità discrete di energia, chiamate fotoni. Ogni fotone possiede anche un carattere ondulatorio che gli conferisce un proprio angolo di polarizzazione, definito come l'angolo tra il piano in cui essi oscillano e il piano di propagazione degli stessi fotoni.\\
    Normalmente una sorgente di luce produce fotoni a polarizzazione arbitraria. Per far assumere una particolare polarizzazione ad un fotone si utilizza un filtro polarizzatore, che permette solo ai fotoni con una determinata polarizzazione di proseguire il loro cammino. Ogni polarizzatore ha un angolo ben preciso di polarizzazione che chiameremo $\theta$.
    Ruotando opportunamente il filtro polarizzatore in modo che permetta il passaggio solo di fotoni con polarizzazione $\theta$, allora tutti i fotoni con polarizzazione diversa da $\theta$ vengono fermati, oppure oltrepassano il filtro con una polarizzazione $\theta$.
    Le leggi della meccanica quantistica ci dicono che un fotone inizialmente polarizzato con un angolo $\phi$ oltrepassa il filtro con la seguente probabilità:
    \begin{equation}
    p_{\theta}(\phi)=\cos^2(\phi-\theta) \label{prob}
    \end{equation}
    La probabilità che venga respinto invece è naturalmente:
    $$1-p_{\theta}(\phi)=\sin^2(\phi-\theta)$$
    Per semplicità, supponiamo di utilizzare raggi luminosi che contengono un singolo fotone polarizzato.
    Per i nostri scopi, utilizzeremo solo quattro angoli di polarizzazione: $\ang{0}$,$\ang{45}$,$\ang{45}$,$\ang{135}$.\\
    I fotoni verranno trasmessi da un capo all'altro della comunicazione tramite fibra ottica, mentre per misurare la polarizzazione del fotone si utilizza un cristallo di calcite. Quando il fotone attraversa il cristallo infatti, possono accadere due cose:
    \begin{itemize}
      \item il fotone lo attraversa in linea retta ed emerge polarizzato perpendicolarmente rispetto all'asse ottico del cristallo
      \item il fotone viene traslato ed emerge polarizzato parallelamente rispetto all'asse ottico.
    \end{itemize}
    Se il fotone è inizialmente polarizzato ortogonalmente rispetto all'asse ottico allora il suo stato non subirà modifiche. Se invece non è così, il fotone seguirà uno dei due cammini con eguale probabilità, subendo un'opportuna ripolarizzazione. Un comportamento del tutto casuale si ha quando la polarizzazione è a metà fra le due direzioni, quindi forma un angolo di $\ang{45}$ o $\ang{135}$ col piano ottico del cristallo: in tal modo ogni informazione sullo stato iniziale viene completamente persa.
    Per questo motivo, nel protocollo BB84 vengono utilizzati gli angoli precedentemente indicati: se per le misure ortogonali non è necessario apportare modifiche al cristallo, per le misure diagonali è sufficiente ruotare il cristallo originale di $\ang{45}$.

    \subsection{Procedimento operativo}
    Ipotizziamo che Alice e Bob vogliano comunicare in maniera cifrata e che utilizzino il protocollo BB84 per trasferire la chiave di criptazione. Ognuno dei bit (unità dell'informazione) che compongono la chiave è rappresentato da un fotone polarizzato come nella tabella seguente:
    \begin{center}
    \begin{tabular}{ |c|c|c|c| }
    \hline
    R & D & Bit \\
    \hline
    $\leftrightarrow$ & $\nearrow$ & 1 \\
    $\updownarrow$ & $\searrow$ & 0 \\
    \hline
    \end{tabular}
    \end{center}
    Supponiamo poi che ogni impulso contenga un solo fotone.
    Il protocollo è il seguente:
    \begin{enumerate}
      \item Alice sceglie una sequenza casuale di bit ed una sequenza casuale di basi di polarizzazione (rettilinea o diagonale) e manda a Bob una sequenza di fotoni, ognuno rappresentante un bit della stringa, nella base scelta.
      \item Bob sceglie casualmente per ogni fotone mandatogli da Alice (e indipendentemente dalle scelte fatte da Alice) se misurare la polarizzazione rettilinea o diagonale e interpreta ogni risultato come 0 o 1, a seconda dell'esito della corrispondente misura. Bob ottiene quindi dati significativi solo dal 50\% dei fotoni che ha misurato (quelli per i quali ha indovinato la  corretta base di polarizzazione) supponendo che non vi siano state alterazioni dovute ad origliamento.
      Notare che ogni misura fatta da Bob altera lo stato del fotone, rendendo impossibile ricostruire il suo stato iniziale.
      \item Bob annuncia pubblicamente le basi con cui ha analizzato i fotoni.
      \item Alice comunica pubblicamente a Bob se per ciascun fotone che egli ha ricevuto ha eseguito il tipo giusto di misurazione. Si scartano tutte le posizioni dei bit per le quali Bob ha eseguito un tipo di misurazione sbagliato o per le quali non è stato rilevato alcun fotone (Ciò può capitare per svariate ragioni, dovute sia ad un eventuale origliatore che all'errore degli strumenti di misura).
      \item Alice e Bob, per verificare se le loro risultanti stringhe di bit sono identiche, confrontano pubblicamente un sottoinsieme casuale dei bit correttamente ricevuti da Bob, cioè con la base esatta. Se tutti i fotoni (o quasi) concordano, Alice e Bob possono concludere che la trasmissione quantistica è stata libera da significativi origliamenti, per cui i rimanenti bit segreti possono costituire la chiave. Se invece vi è stato un notevole origliamento, la trasmissione è scartata e si riprova con un nuovo gruppo di fotoni.
    \end{enumerate}
    In seguito è riportato un esempio di trasmissione della chiave quantistica da parte dei due interlocutori.
    \begin{center}
    \begin{tabular}{| c | c c c c c c c c c c c c c c c |}
      \hline
     1a.& 0 & 1 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1\\
     1b.&D & R & D & R & R & R & R & R  & D & D & R & D & D & D & R\\
     1c. & $\nearrow$ & $\updownarrow$&$\searrow$ &$\leftrightarrow$ & $\updownarrow$& $\updownarrow$& $\leftrightarrow$&$\leftrightarrow$ & $\searrow$& $\nearrow$&$\updownarrow$&$\searrow$&$\nearrow$ & $\nearrow$ & $\updownarrow$ \\
     2a. & R&D&D&R&R&D&D&R&D&R&D&D&D&D&R\\
     2b. &1& &1& &1&0&0&0&&1&1&1&&1&0\\
     3. & R&&D&&R&D&D&R&&R&D&D&&D&R\\
     4a. &&&OK&&OK&&&OK&&&&OK&&OK&OK\\
     4b. &&&1&&1&&&0&&&&1&&0&1\\
     5a.&&&&&1&&&&&&&&&0&\\
     5b.&&&&&OK&&&&&&&&&OK&\\
     5c. &&&1&&&&&0&&&&1&&&1\\
      \hline
     \end{tabular}
    \end{center}

    \begin{center}
    \begin{tabular}{|c | c|}
      \hline
      \multicolumn{2}{|c|}{\textit{Trasmissione quantistica} }\\
      \hline
      1a.& Bit scelti da Alice\\
      1b.&Basi scelte da Alice\\
      1c. & Fotoni polarizzati spediti sul canale quantistico\\
      2a.& Basi scelte da Bob per misurare i fotoni\\
      2b.&Bit ricevuti da Bob\\
      \hline
      \multicolumn{2}{|c|}{\textit{Discussione pubblica}}\\
      \hline
      3. & Bob dichiara le basi che ha utilizzato\\
      4a.  & Alice dice a Bob quali basi erano corrette \\
      4b. & Bit validi per la chiave di criptazione\\
      5a. &Bob rivela alcuni bit della chiave ottenuta\\
      5b. & Alice conferma i bit inviati, verificando la validità della chiave\\
      \hline
      \multicolumn{2}{|c|}{\textit{Risultato}}\\
      \hline
      5c.& Bit rimanenti utilizzati nella chiave\\
      \hline
    \end{tabular}
    \end{center}
    ~
    \subsection{La meccanica quantistica ci fornisce il certificato di sicurezza}
    Una delle classiche strategie di intercettazione utilizzate è il cosiddetto \textit{Man-in-the-middle}: L'origliatore, tipicamente chiamato Eva, intercetta le comunicazioni e ritrasmette al destinatario ciò che riceve.
    In questo caso, Eva intercetta ogni fotone in una delle due basi e spedisce a Bob un fotone nello stato che ha rilevato:
    in questo modo le informazioni corrrettamente captate saranno il 50\% di quelle totali.
    Infatti,dalla \eqref{prob} possiamo ricavare le probabilità che ogni fotone attraversi una base:
    \begin{center}
      \begin{tabular}{|c|c|c|c|c|}
        \hline
        &$\ang{0}$&$\ang{90}$&$\ang{45}$&$\ang{135}$\\
        \hline
        $\leftrightarrow$&1&0&0.5&0.5\\
        \hline
        $\updownarrow$&0&1&0.5&0.5\\
        \hline
        $\nearrow$&0.5&0.5&1&0\\
        \hline
        $\searrow$&0.5&0.50&1&0\\
        \hline
      \end{tabular}
    \end{center}
    Ad esempio, la probabilià che Eva riesca a captare correttamente un fotone polarizzato a $\ang{90}$ vale:
    $$p(\ang{90})=\frac{p_{\ang{0}}(\ang{90})+p_{\ang{45}}(\ang{90})+p_{\ang{90}}(\ang{90})+p_{\ang{135}}(\ang{90})}{4}=\frac{0+1+0.5+0.5}{4}=0.5$$
    La probablità che Eva spedisca il bit correttamente a Bob è però diversa da $p(\ang{90})$, perché per il principio di indeterminazione di Heisenberg, la misura comporta il collasso dello stato quantico del fotone: se inzialmente la polarizzazione della particella non è concorde con la base utilizzata, la misura obbliga il fotone ad orientarsi lungo uno dei due assi ortogonali del filtro utilizzato.
    Di conseguenza, la probabilità che Bob ricevi correttamente il bit di Alice è descritta dalla seguente formula:
    \begin{equation*}
      \frac{\displaystyle\sum_{i\in A}\displaystyle\sum_{j\in A} p_i(\ang{90})\cdot p_j(\ang{90})}{16}=0.25
    \end{equation*}
    dove $A=\{\ang{0},\ang{45},\ang{90},\ang{135}\}$.\\
    La probabilità di errore molto elevata permette di stabilire se la chiave è stata trasmessa in modo sicuro.
    Se Eva decide di intercettare solo una parte dei bit totali, diventa più complesso stabilire se ci sono state interferenze; è stato comunque dimostrato che con un errore del 15\% è possibile stabilire con certezza la presenza di un intermediario.\\\\
    Un'altra strategia che Eva potrebbe seguire è copiare il fotone trasmesso da Alice per poi effettuare le misurazioni quando le basi vengono rilevate. Oltre alle difficoltà incontrate nel conservare la particella, è dimostrato che clonare perfettamente una particella quantistica non è possibile.
    Tuttavia, dobbiamo tenere in considerazione che esistono delle macchine che raggiungono un ottimo stato di clonazione compatibili col teorema di non-clonazione sopra citato.\\\\
     Per concludere, non esistono metodi sufficientemente precisi per intercettare correttamente il messaggio senza essere scoperti dai due interlocutori legittimi.
     \section{Conclusioni}




\end{document}
